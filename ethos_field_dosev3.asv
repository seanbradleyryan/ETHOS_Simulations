%% ETHOS IMRT Field-by-Field Dose Calculator
% Purpose: Calculate individual field doses from ETHOS exported IMRT data
% Uses MATRAD for dose calculation
% Author: Generated for ETHOS dose analysis
% Date: 2025
%
% MODIFIED: Field doses and CT are now resampled to RTDOSE grid dimensions
%           instead of resampling RTDOSE to CT grid

clear; clc; close all;

%% Configuration
% Patient and session arrays (expandable for batch processing)
ids = {'1194203'};
sessions = {'Session_1'};

% Base directory
wd = '/mnt/weka/home/80030361/ETHOS_Simulations';
matradPath = '/mnt/weka/home/80030361/MATLAB/Addons/matRad';

% Verify paths exist
fprintf('Verifying paths...\n');
if ~exist(wd, 'dir')
    error('Working directory does not exist: %s', wd);
else
    fprintf('  - Working directory OK: %s\n', wd);
end

if ~exist(matradPath, 'dir')
    error('matRad path does not exist: %s', matradPath);
else
    fprintf('  - matRad path OK: %s\n', matradPath);
end

% Add MATRAD to path
addpath(genpath(matradPath));
fprintf('  - matRad added to MATLAB path\n');

% Initialize MATRAD (required for some versions)
fprintf('Initializing MATRAD...\n');
try
    matRad_rc; % matRad run configuration/initialization
    fprintf('  - MATRAD initialized successfully\n');
catch
    fprintf('  - matRad_rc not found, trying matRad_cfg...\n');
    try
        matRad_cfg = MatRad_Config.instance();
        fprintf('  - MATRAD configured successfully\n');
    catch
        fprintf('  - Direct initialization not available, continuing...\n');
    end
end

% Verify MATRAD functions are available
fprintf('Verifying MATRAD installation...\n');

% Check for matRad_DicomImporter class
classPath = fullfile(matradPath, 'dicom', '@matRad_DicomImporter');
if exist(classPath, 'dir')
    fprintf('  - Found: matRad_DicomImporter class at %s\n', classPath);
else
    fprintf('  - WARNING: matRad_DicomImporter class not found at expected location\n');
end

% Check if class can be instantiated
try
    testPath = tempname;
    mkdir(testPath);
    testImporter = matRad_DicomImporter(testPath);
    fprintf('  - matRad_DicomImporter class successfully instantiated\n');
    rmdir(testPath);
    clear testImporter;
catch ME
    fprintf('  - WARNING: Could not instantiate matRad_DicomImporter: %s\n', ME.message);
end

% Check for other essential matRad functions
essentialFunctions = {'matRad_calcDoseInfluence', 'matRad_generateStf', 'matRad_calcDoseForward'};
for i = 1:length(essentialFunctions)
    if exist(essentialFunctions{i}, 'file')
        fprintf('  - Found: %s\n', essentialFunctions{i});
    else
        fprintf('  - WARNING: %s not found\n', essentialFunctions{i});
    end
end

% Check for reduce_collimator helper function
if exist('reduce_collimator', 'file')
    fprintf('  - Found: reduce_collimator (MLC reduction)\n');
else
    fprintf('  - WARNING: reduce_collimator.m not found\n');
    fprintf('    This function is needed to convert dual-layer MLC to single-layer\n');
    fprintf('    Place reduce_collimator.m in the current directory or MATLAB path\n');
end

%% Main Processing Loop
for idxID = 1:length(ids)
    for idxSession = 1:length(sessions)
        
        currentID = ids{idxID};
        currentSession = sessions{idxSession};
        
        fprintf('\n========================================\n');
        fprintf('Processing Patient: %s, Session: %s\n', currentID, currentSession);
        fprintf('========================================\n');
        
        % Define paths
        rawwd = fullfile(wd, 'EthosExports', currentID, 'Pancreas', currentSession);
        dicomPath = fullfile(rawwd, 'sct');
        outputPath = fullfile(wd, 'FieldDoses', currentID, currentSession);
        
        % Create output directory
        if ~exist(outputPath, 'dir')
            mkdir(outputPath);
        end
        
        %% Step 1: Import DICOM data using MATRAD
        fprintf('\n[1/7] Importing DICOM data...\n');
        
        try
            % Use matRad_DicomImporter class (object-oriented approach)
            fprintf('  Creating matRad_DicomImporter object...\n');
            
            % Create importer instance
            importer = matRad_DicomImporter(dicomPath);
            
            % Import all DICOM data (CT, structures, plan)
            % Note: This populates variables directly in workspace without output args
            fprintf('  Importing DICOM files...\n');
            importer.matRad_importDicom();
            
            fprintf('  - Data imported successfully\n');
            
            % Display CT information
            fprintf('  - CT dimensions: %d x %d x %d\n', ct.cubeDim(1), ct.cubeDim(2), ct.cubeDim(3));
            fprintf('  - CT resolution: %.2f x %.2f x %.2f mm\n', ...
                ct.resolution.x, ct.resolution.y, ct.resolution.z);
            fprintf('  - Number of structures: %d\n', size(cst, 1));
            if isfield(pln, 'propStf')
                fprintf('  - Number of beams: %d\n', pln.propStf.numOfBeams);
            elseif isfield(pln, 'numOfBeams')
                fprintf('  - Number of beams: %d\n', pln.numOfBeams);
            end
            
        catch ME
            fprintf('Error importing DICOM data: %s\n', ME.message);
            fprintf('Stack trace:\n');
            for k = 1:length(ME.stack)
                fprintf('  %s (line %d)\n', ME.stack(k).name, ME.stack(k).line);
            end
            continue;
        end
        
        %% Step 2: Load reference RTDOSE and extract spatial coordinates
        fprintf('\n[2/7] Loading reference RTDOSE and extracting spatial coordinates...\n');
        
        % Initialize spatial coordinate structures
        ctSpatial = struct();
        doseSpatial = struct();
        
        try
            % Extract CT spatial coordinates from DICOM files
            fprintf('  Extracting CT spatial coordinates...\n');
            ctFiles = dir(fullfile(dicomPath, 'CT*.dcm'));
            if isempty(ctFiles)
                ctFiles = dir(fullfile(dicomPath, '*CT*.dcm'));
            end
            
            if ~isempty(ctFiles)
                % Read first CT slice for ImagePositionPatient and PixelSpacing
                ctInfo = dicominfo(fullfile(ctFiles(1).folder, ctFiles(1).name));
                
                ctSpatial.ImagePositionPatient = ctInfo.ImagePositionPatient;
                ctSpatial.PixelSpacing = ctInfo.PixelSpacing;
                ctSpatial.Rows = ctInfo.Rows;
                ctSpatial.Columns = ctInfo.Columns;
                
                % Get all slice positions to determine Z coordinates
                slicePositions = zeros(length(ctFiles), 1);
                for i = 1:length(ctFiles)
                    tempInfo = dicominfo(fullfile(ctFiles(i).folder, ctFiles(i).name));
                    slicePositions(i) = tempInfo.ImagePositionPatient(3);
                end
                slicePositions = sort(slicePositions);
                
                ctSpatial.SlicePositions = slicePositions;
                ctSpatial.SliceThickness = abs(slicePositions(2) - slicePositions(1));
                ctSpatial.NumSlices = length(slicePositions);
                
                % Calculate CT bounding box in patient coordinates
                ctSpatial.XMin = ctSpatial.ImagePositionPatient(1);
                ctSpatial.XMax = ctSpatial.XMin + (ctSpatial.Columns - 1) * ctSpatial.PixelSpacing(2);
                ctSpatial.YMin = ctSpatial.ImagePositionPatient(2);
                ctSpatial.YMax = ctSpatial.YMin + (ctSpatial.Rows - 1) * ctSpatial.PixelSpacing(1);
                ctSpatial.ZMin = min(slicePositions);
                ctSpatial.ZMax = max(slicePositions);
                
                fprintf('    CT spatial extent:\n');
                fprintf('      X: [%.2f, %.2f] mm\n', ctSpatial.XMin, ctSpatial.XMax);
                fprintf('      Y: [%.2f, %.2f] mm\n', ctSpatial.YMin, ctSpatial.YMax);
                fprintf('      Z: [%.2f, %.2f] mm\n', ctSpatial.ZMin, ctSpatial.ZMax);
                fprintf('      Resolution: [%.2f, %.2f, %.2f] mm\n', ...
                    ctSpatial.PixelSpacing(1), ctSpatial.PixelSpacing(2), ctSpatial.SliceThickness);
            else
                fprintf('  WARNING: No CT DICOM files found for spatial extraction\n');
            end
            
            % Load RTDOSE and extract spatial coordinates
            rtdoseFile = dir(fullfile(dicomPath, 'RD*.dcm'));
            if isempty(rtdoseFile)
                rtdoseFile = dir(fullfile(dicomPath, '*RTDOSE*.dcm'));
            end
            
            if ~isempty(rtdoseFile)
                rtdoseInfo = dicominfo(fullfile(rtdoseFile(1).folder, rtdoseFile(1).name));
                referenceDose = dicomread(fullfile(rtdoseFile(1).folder, rtdoseFile(1).name));
                
                % RTDOSE is often 4D with singleton dimension - squeeze it
                referenceDose = squeeze(referenceDose);
                
                % Apply scaling
                referenceDose = double(referenceDose) * rtdoseInfo.DoseGridScaling;
                
                fprintf('  - Reference dose grid: %d x %d x %d\n', ...
                    size(referenceDose, 1), size(referenceDose, 2), size(referenceDose, 3));
                fprintf('  - Max dose: %.2f Gy\n', max(referenceDose(:)));
                
                % Extract RTDOSE spatial coordinates
                doseSpatial.ImagePositionPatient = rtdoseInfo.ImagePositionPatient;
                doseSpatial.PixelSpacing = rtdoseInfo.PixelSpacing;
                doseSpatial.Rows = rtdoseInfo.Rows;
                doseSpatial.Columns = rtdoseInfo.Columns;
                
                % Z resolution from GridFrameOffsetVector (multiframe DICOM)
                if isfield(rtdoseInfo, 'GridFrameOffsetVector') && length(rtdoseInfo.GridFrameOffsetVector) > 1
                    doseSpatial.GridFrameOffsetVector = rtdoseInfo.GridFrameOffsetVector;
                    doseSpatial.SliceThickness = abs(rtdoseInfo.GridFrameOffsetVector(2) - rtdoseInfo.GridFrameOffsetVector(1));
                    doseSpatial.NumSlices = length(rtdoseInfo.GridFrameOffsetVector);
                    fprintf('  - Z resolution from GridFrameOffsetVector: %.3f mm\n', doseSpatial.SliceThickness);
                elseif isfield(rtdoseInfo, 'SliceThickness')
                    doseSpatial.SliceThickness = rtdoseInfo.SliceThickness;
                    doseSpatial.NumSlices = size(referenceDose, 3);
                    doseSpatial.GridFrameOffsetVector = (0:doseSpatial.NumSlices-1) * doseSpatial.SliceThickness;
                    fprintf('  - Z resolution from SliceThickness: %.3f mm\n', doseSpatial.SliceThickness);
                else
                    % Fallback
                    doseSpatial.SliceThickness = 2.5;  % Common default
                    doseSpatial.NumSlices = size(referenceDose, 3);
                    doseSpatial.GridFrameOffsetVector = (0:doseSpatial.NumSlices-1) * doseSpatial.SliceThickness;
                    fprintf('  - WARNING: Z resolution not found, using default: %.3f mm\n', doseSpatial.SliceThickness);
                end
                
                % Calculate RTDOSE bounding box in patient coordinates
                doseSpatial.XMin = doseSpatial.ImagePositionPatient(1);
                doseSpatial.XMax = doseSpatial.XMin + (doseSpatial.Columns - 1) * doseSpatial.PixelSpacing(2);
                doseSpatial.YMin = doseSpatial.ImagePositionPatient(2);
                doseSpatial.YMax = doseSpatial.YMin + (doseSpatial.Rows - 1) * doseSpatial.PixelSpacing(1);
                doseSpatial.ZMin = doseSpatial.ImagePositionPatient(3);
                doseSpatial.ZMax = doseSpatial.ZMin + doseSpatial.GridFrameOffsetVector(end);
                
                % Store dose grid parameters for later use
                doseGrid.resolution = [doseSpatial.PixelSpacing(1), doseSpatial.PixelSpacing(2), doseSpatial.SliceThickness];
                doseGrid.dimensions = [doseSpatial.Rows, doseSpatial.Columns, doseSpatial.NumSlices];
                doseGrid.ImagePositionPatient = doseSpatial.ImagePositionPatient;
                
                fprintf('    RTDOSE spatial extent:\n');
                fprintf('      X: [%.2f, %.2f] mm\n', doseSpatial.XMin, doseSpatial.XMax);
                fprintf('      Y: [%.2f, %.2f] mm\n', doseSpatial.YMin, doseSpatial.YMax);
                fprintf('      Z: [%.2f, %.2f] mm\n', doseSpatial.ZMin, doseSpatial.ZMax);
                fprintf('      Resolution: [%.3f, %.3f, %.3f] mm\n', ...
                    doseGrid.resolution(1), doseGrid.resolution(2), doseGrid.resolution(3));
                fprintf('      Dimensions: [%d, %d, %d]\n', ...
                    doseGrid.dimensions(1), doseGrid.dimensions(2), doseGrid.dimensions(3));
                
            else
                fprintf('  WARNING: No RTDOSE file found\n');
                doseGrid.resolution = [ct.resolution.x, ct.resolution.y, ct.resolution.z];
                doseGrid.dimensions = ct.cubeDim;
                referenceDose = [];
            end
            
        catch ME
            fprintf('WARNING: Could not load RTDOSE: %s\n', ME.message);
            doseGrid.resolution = [ct.resolution.x, ct.resolution.y, ct.resolution.z];
            doseGrid.dimensions = ct.cubeDim;
            referenceDose = [];
        end
        
        %% Step 3: Configure dose calculation
        fprintf('\n[3/7] Configuring dose calculation...\n');
        
        % Check and override machine specification
        if isfield(pln, 'machine')
            fprintf('  - Original machine: %s\n', pln.machine);
        end
        
        % Check available machine files
        machineDir = fullfile(matradPath, 'basedata');
        if exist(machineDir, 'dir')
            machineFiles = dir(fullfile(machineDir, 'photons*.mat'));
            if ~isempty(machineFiles)
                fprintf('  - Available machine files:\n');
                for i = 1:min(5, length(machineFiles))
                    [~, machineName, ~] = fileparts(machineFiles(i).name);
                    fprintf('    %d. %s\n', i, machineName);
                end
                
                % Use first generic machine or specific one
                genericMachines = machineFiles(contains({machineFiles.name}, 'Generic', 'IgnoreCase', true));
                if ~isempty(genericMachines)
                    [~, selectedMachine, ~] = fileparts(genericMachines(1).name);
                    fprintf('  - Using generic machine: %s\n', selectedMachine);
                    pln.machine = selectedMachine;
                else
                    % Use first available photon machine
                    [~, selectedMachine, ~] = fileparts(machineFiles(1).name);
                    fprintf('  - Using machine: %s\n', selectedMachine);
                    pln.machine = selectedMachine;
                end
            else
                fprintf('  - Warning: No machine files found, using default\n');
                pln.machine = 'Generic';
            end
        else
            fprintf('  - Warning: Machine directory not found, using default\n');
            pln.machine = 'Generic';
        end
        
        % Set up dose calculation parameters - use CT resolution for calculation
        % (will be resampled to RTDOSE grid later)
        pln.propStf.bixelWidth = 5; % mm
        pln.propDoseCalc.doseGrid.resolution.x = ct.resolution.x;
        pln.propDoseCalc.doseGrid.resolution.y = ct.resolution.y;
        pln.propDoseCalc.doseGrid.resolution.z = ct.resolution.z;
        
        % Set algorithm (typically 'pencilBeam' for photons)
        if strcmp(pln.radiationMode, 'photons')
            pln.propDoseCalc.engine = 'pencilBeam';
        else
            pln.propDoseCalc.engine = 'matRad_pencilBeam';
        end
        
        fprintf('  - Radiation mode: %s\n', pln.radiationMode);
        fprintf('  - Machine: %s\n', pln.machine);
        fprintf('  - Dose engine: %s\n', pln.propDoseCalc.engine);
        fprintf('  - Calculation grid resolution: [%.2f, %.2f, %.2f] mm (CT resolution)\n', ...
            ct.resolution.x, ct.resolution.y, ct.resolution.z);
        fprintf('  - Final output will be resampled to RTDOSE grid: [%.2f, %.2f, %.2f] mm\n', ...
            doseGrid.resolution(1), doseGrid.resolution(2), doseGrid.resolution(3));
        
        %% Reduce dual-layer MLC to single-layer (if present)
        fprintf('\n  Checking for dual-layer MLC in imported plan...\n');
        if isfield(pln, 'propStf') && isfield(pln.propStf, 'beam') && ...
           length(pln.propStf.beam) > 0 && isfield(pln.propStf.beam(1), 'shape')
            fprintf('  - MLC shape data found in pln.propStf.beam\n');
            % MLC data was imported by matRad_DicomImporter
            % Call the collimator reduction function to convert dual-layer to single-layer
            if exist('reduce_collimator', 'file')
                fprintf('  - Calling reduce_collimator to convert dual-layer to single-layer...\n');
                pln = reduce_collimator(pln);
                fprintf('  - Collimator reduction complete\n');
            else
                fprintf('   WARNING: reduce_collimator.m not found!\n');
                fprintf('    Dual-layer MLC will not be reduced\n');
                fprintf('    This may cause MATRAD to fail or produce incorrect results\n');
                fprintf('    Place reduce_collimator.m in the current directory or MATLAB path\n');
            end
        else
            fprintf('  - No MLC shape data found in imported plan\n');
            fprintf('  - MATRAD will calculate open field doses\n');
        end
        
        %% Manual MLC/Collimation Extraction
        fprintf('\n  Extracting MLC/collimation data from RTPLAN...\n');
        try
            % Find RTPLAN file
            rtplanFile = dir(fullfile(dicomPath, 'RP*.dcm'));
            if isempty(rtplanFile)
                rtplanFile = dir(fullfile(dicomPath, '*RTPLAN*.dcm'));
            end
            
            if ~isempty(rtplanFile)
                rtplanInfo = dicominfo(fullfile(rtplanFile(1).folder, rtplanFile(1).name));
                
                if isfield(rtplanInfo, 'BeamSequence')
                    numBeams = length(fieldnames(rtplanInfo.BeamSequence));
                    
                    % Initialize collimation structure if it doesn't exist
                    if ~isfield(pln.propStf, 'collimation')
                        pln.propStf.collimation = struct();
                    end
                    
                    mlcExtracted = false;
                    
                    for beamIdx = 1:numBeams
                        beamField = sprintf('Item_%d', beamIdx);
                        beam = rtplanInfo.BeamSequence.(beamField);
                        
                        % Initialize beam collimation structure
                        if ~isfield(pln.propStf, 'beam')
                            pln.propStf.beam = struct();
                        end
                        
                        if isfield(beam, 'ControlPointSequence')
                            numCP = length(fieldnames(beam.ControlPointSequence));
                            
                            % For simplicity, use first control point aperture
                            % (represents initial field shape)
                            cpField = 'Item_1';
                            cp = beam.ControlPointSequence.(cpField);
                            
                            if isfield(cp, 'BeamLimitingDevicePositionSequence')
                                numDevices = length(fieldnames(cp.BeamLimitingDevicePositionSequence));
                                
                                jawX = [];
                                jawY = [];
                                mlcX = [];
                                mlcY = [];
                                
                                for devIdx = 1:numDevices
                                    devField = sprintf('Item_%d', devIdx);
                                    device = cp.BeamLimitingDevicePositionSequence.(devField);
                                    
                                    if isfield(device, 'RTBeamLimitingDeviceType')
                                        deviceType = device.RTBeamLimitingDeviceType;
                                        
                                        if isfield(device, 'LeafJawPositions')
                                            positions = device.LeafJawPositions;
                                            
                                            % Classify device type
                                            if contains(deviceType, 'ASYMX', 'IgnoreCase', true) || ...
                                               strcmp(deviceType, 'X')
                                                jawX = positions;
                                                fprintf('    Beam %d: X Jaws = [%.2f, %.2f] mm\n', ...
                                                    beamIdx, positions(1), positions(2));
                                            elseif contains(deviceType, 'ASYMY', 'IgnoreCase', true) || ...
                                                   strcmp(deviceType, 'Y')
                                                jawY = positions;
                                                fprintf('    Beam %d: Y Jaws = [%.2f, %.2f] mm\n', ...
                                                    beamIdx, positions(1), positions(2));
                                            elseif contains(deviceType, 'MLCX', 'IgnoreCase', true) || ...
                                                   contains(deviceType, 'MLC', 'IgnoreCase', true)
                                                mlcX = positions;
                                                numLeaves = length(positions) / 2;
                                                fprintf('    Beam %d: MLC X with %d leaf pairs\n', ...
                                                    beamIdx, numLeaves);
                                                mlcExtracted = true;
                                            elseif contains(deviceType, 'MLCY', 'IgnoreCase', true)
                                                mlcY = positions;
                                                numLeaves = length(positions) / 2;
                                                fprintf('    Beam %d: MLC Y with %d leaf pairs\n', ...
                                                    beamIdx, numLeaves);
                                            end
                                        end
                                    end
                                end
                                
                                % Store in pln structure
                                pln.propStf.beam(beamIdx).jaw.x = jawX;
                                pln.propStf.beam(beamIdx).jaw.y = jawY;
                                
                                if ~isempty(mlcX)
                                    pln.propStf.beam(beamIdx).shape.x = mlcX;
                                end
                                if ~isempty(mlcY)
                                    pln.propStf.beam(beamIdx).shape.y = mlcY;
                                end
                            end
                        end
                    end
                    
                    if mlcExtracted
                        fprintf('   MLC positions extracted for %d beams\n', numBeams);
                        fprintf('   Stored in pln.propStf.beam structure\n');
                        
                        % Set collimation flag
                        pln.propStf.collimation.type = 'mlc';
                        fprintf('   Set pln.propStf.collimation.type = ''mlc''\n');
                    else
                        fprintf('   No MLC data found in control points\n');
                    end
                end
            end
        catch ME
            fprintf('   Error extracting MLC data: %s\n', ME.message);
            fprintf('    Will proceed with open field calculation\n');
        end
        
        %% Step 4: Generate steering information
        fprintf('\n[4/7] Generating steering information...\n');
        
        try
            stf = matRad_generateStf(ct, cst, pln);
            fprintf('  - Steering file generated for %d beams\n', length(stf));
            
            % Display beam information
            for i = 1:length(stf)
                fprintf('    Beam %d: Gantry=%.1f, Couch=%.1f, Rays=%d\n', ...
                    i, stf(i).gantryAngle, stf(i).couchAngle, length(stf(i).ray));
            end
            
            % Diagnose plan structure for weight extraction
            fprintf('\n  Diagnosing plan structure for weights:\n');
            if isfield(pln, 'w')
                fprintf('    - pln.w exists: %d values, sum=%.2f\n', length(pln.w), sum(pln.w));
            else
                fprintf('    - pln.w does NOT exist\n');
            end
            
            % Check MLC status in plan and stf
            fprintf('\n  MLC status check:\n');
            if isfield(pln, 'propStf') && isfield(pln.propStf, 'beam') && ...
               length(pln.propStf.beam) > 0 && isfield(pln.propStf.beam(1), 'shape')
                fprintf('    - pln.propStf.beam(1).shape exists\n');
                if isfield(pln.propStf.beam(1).shape, 'x')
                    numLeaves = length(pln.propStf.beam(1).shape.x) / 2;
                    fprintf('      MLC X: %d leaf pairs\n', numLeaves);
                end
            else
                fprintf('    - No MLC shape data in pln.propStf.beam\n');
            end
            
            if isfield(stf, 'shape') && isfield(stf(1), 'shape')
                fprintf('    - stf(1).shape exists (MLC in steering file)\n');
            elseif isfield(stf(1), 'ray') && isfield(stf(1).ray(1), 'shape')
                fprintf('    - stf(1).ray(1).shape exists (MLC per ray)\n');
            else
                fprintf('    - No MLC shape data in stf (open field calculation)\n');
            end
            
            % Manual weight extraction from RTPLAN DICOM
            fprintf('\n  Attempting manual weight extraction from RTPLAN...\n');
            try
                % Find RTPLAN file
                rtplanFile = dir(fullfile(dicomPath, 'RP*.dcm'));
                if isempty(rtplanFile)
                    rtplanFile = dir(fullfile(dicomPath, '*RTPLAN*.dcm'));
                end
                
                if ~isempty(rtplanFile)
                    rtplanInfo = dicominfo(fullfile(rtplanFile(1).folder, rtplanFile(1).name));
                    fprintf('    - Found RTPLAN file: %s\n', rtplanFile(1).name);
                    
                    % Extract weights from BeamSequence
                    if isfield(rtplanInfo, 'BeamSequence')
                        numBeams = length(fieldnames(rtplanInfo.BeamSequence));
                        fprintf('    - BeamSequence contains %d beams\n', numBeams);
                        
                        % Try to get per-beam metersets from FractionGroupSequence first
                        beamMetersets = [];
                        if isfield(rtplanInfo, 'FractionGroupSequence')
                            fg = rtplanInfo.FractionGroupSequence.Item_1;
                            if isfield(fg, 'ReferencedBeamSequence')
                                numRefBeams = length(fieldnames(fg.ReferencedBeamSequence));
                                beamMetersets = zeros(numRefBeams, 1);
                                for i = 1:numRefBeams
                                    refBeam = fg.ReferencedBeamSequence.(sprintf('Item_%d', i));
                                    if isfield(refBeam, 'BeamMeterset')
                                        beamMetersets(i) = refBeam.BeamMeterset;
                                    end
                                end
                                fprintf('    - Extracted beam metersets from FractionGroupSequence\n');
                            end
                        end
                        
                        % Initialize weight vector
                        allWeights = [];
                        
                        for beamIdx = 1:numBeams
                            beamField = sprintf('Item_%d', beamIdx);
                            beam = rtplanInfo.BeamSequence.(beamField);
                            
                            % Get number of bixels for this beam
                            numRays = stf(beamIdx).numOfRays;
                            numEnergies = length(stf(beamIdx).ray(1).energy);
                            numBixels = numRays * numEnergies;
                            
                            beamWeights = [];
                            
                            % Method 1: Try control point sequence for segment weights
                            if isfield(beam, 'ControlPointSequence')
                                numCP = length(fieldnames(beam.ControlPointSequence));
                                
                                % Extract cumulative meterset weights
                                cumulativeWeights = zeros(numCP, 1);
                                for cpIdx = 1:numCP
                                    cpField = sprintf('Item_%d', cpIdx);
                                    cp = beam.ControlPointSequence.(cpField);
                                    if isfield(cp, 'CumulativeMetersetWeight')
                                        cumulativeWeights(cpIdx) = cp.CumulativeMetersetWeight;
                                    end
                                end
                                
                                % Use final cumulative weight if available
                                if any(cumulativeWeights > 0)
                                    finalWeight = max(cumulativeWeights);
                                    fprintf('      Beam %d: FinalCumulativeMetersetWeight = %.4f\n', ...
                                        beamIdx, finalWeight);
                                end
                            end
                            
                            % Method 2: Use beam meterset from FractionGroupSequence if available
                            if ~isempty(beamMetersets) && beamIdx <= length(beamMetersets)
                                % Distribute beam meterset uniformly across all bixels
                                beamWeights = ones(numBixels, 1) * (beamMetersets(beamIdx) / numBixels);
                                fprintf('      Beam %d: Using meterset %.4f distributed across %d bixels\n', ...
                                    beamIdx, beamMetersets(beamIdx), numBixels);
                            else
                                % Fallback: uniform weights
                                beamWeights = ones(numBixels, 1);
                                fprintf('      Beam %d: Using uniform weights for %d bixels\n', ...
                                    beamIdx, numBixels);
                            end
                            
                            allWeights = [allWeights; beamWeights];
                        end
                        
                        % Store in pln.w
                        if ~isempty(allWeights)
                            pln.w = allWeights;
                            fprintf('     Successfully created weight vector with %d values\n', length(pln.w));
                            fprintf('      Total weight sum: %.2f\n', sum(pln.w));
                            fprintf('      Mean weight: %.4f\n', mean(pln.w));
                        else
                            fprintf('     Could not extract weights, will use uniform weights\n');
                        end
                    end
                    
                    % Check for additional weight sources
                    if isfield(rtplanInfo, 'FractionGroupSequence')
                        fg = rtplanInfo.FractionGroupSequence.Item_1;
                        if isfield(fg, 'ReferencedBeamSequence')
                            fprintf('    - Found ReferencedBeamSequence\n');
                            numRefBeams = length(fieldnames(fg.ReferencedBeamSequence));
                            for i = 1:numRefBeams
                                refBeam = fg.ReferencedBeamSequence.(sprintf('Item_%d', i));
                                if isfield(refBeam, 'BeamMeterset')
                                    fprintf('      Beam %d meterset: %.4f\n', i, refBeam.BeamMeterset);
                                end
                            end
                        end
                    end
                end
            catch ME
                fprintf('     Error during manual weight extraction: %s\n', ME.message);
            end
            
        catch ME
            fprintf('Error generating steering file: %s\n', ME.message);
            continue;
        end
        
        %% Step 5: Calculate individual field doses
        fprintf('\n[5/7] Calculating individual field doses...\n');
        
        % Re-check if weights are now available after manual extraction
        if isfield(pln, 'w') && ~isempty(pln.w)
            fprintf('  - Using extracted weights from RTPLAN: %d values (sum=%.2f)\n', ...
                length(pln.w), sum(pln.w));
        else
            fprintf('  - WARNING: No weights available, will use uniform weights\n');
        end
        
        % Initialize storage for field doses
        fieldDoses = cell(length(stf), 1);
        totalDose = [];  % Will be initialized after first successful calculation
        calculatedGridSize = [];  % Track the calculation grid size
        
        for beamIdx = 1:length(stf)
            fprintf('  Processing Beam %d/%d (Gantry: %.1f)...\n', ...
                beamIdx, length(stf), stf(beamIdx).gantryAngle);
            
            % Create temporary plan with single beam
            plnSingle = pln;
            plnSingle.propStf.numOfBeams = 1;
            plnSingle.propStf.isoCenter = stf(beamIdx).isoCenter;
            
            % Create single-beam steering file
            stfSingle = stf(beamIdx);
            
            % Calculate dose influence matrix for this beam
            try
                fprintf('    Calculating dose influence matrix...\n');
                dij = matRad_calcDoseInfluence(ct, cst, stfSingle, plnSingle);
                fprintf('    - Total bixels in dij: %d\n', dij.totalNumOfBixels);
            catch ME
                fprintf('     ERROR in dose influence calculation: %s\n', ME.message);
                fieldDoses{beamIdx} = [];
                continue;
            end
            
            % Initialize weights vector
            w = ones(dij.totalNumOfBixels, 1);
            
            % Try to extract weights from imported plan
            if isfield(pln, 'w') && ~isempty(pln.w)
                % Calculate offset for this beam in the global weight vector
                offset = 0;
                for b = 1:(beamIdx-1)
                    numRays = stf(b).numOfRays;
                    numEnergies = length(stf(b).ray(1).energy);
                    offset = offset + numRays * numEnergies;
                end
                
                numBixelsThisBeam = stfSingle.numOfRays * length(stfSingle.ray(1).energy);
                fprintf('    - Extracting weights: offset=%d, num_bixels=%d\n', offset, numBixelsThisBeam);
                
                if offset + numBixelsThisBeam <= length(pln.w)
                    w = pln.w(offset+1:offset+numBixelsThisBeam);
                    fprintf('    - Using imported weights (sum=%.2f)\n', sum(w));
                else
                    fprintf('    - WARNING: Not enough weights in pln.w, using uniform weights\n');
                    w(:) = 1.0;
                end
            else
                fprintf('    - Using uniform weights (sum=%.2f)\n', sum(w));
            end
            
            % Calculate dose for this field
            try
                fprintf('    Calculating forward dose...\n');
                resultGUI = matRad_calcDoseForward(ct, cst, stfSingle, plnSingle, w);
            catch ME
                fprintf('     ERROR in forward dose calculation: %s\n', ME.message);
                fieldDoses{beamIdx} = [];
                continue;
            end
            
            % Validate and store the result
            if ~isfield(resultGUI, 'physicalDose')
                fprintf('     ERROR: No physicalDose field in result!\n');
                fieldDoses{beamIdx} = [];
                continue;
            end
            
            % Check dose values
            maxDoseField = max(resultGUI.physicalDose(:));
            nonzeroDose = nnz(resultGUI.physicalDose);
            doseSize = size(resultGUI.physicalDose);
            
            fprintf('    - Calculated dose grid: %d x %d x %d\n', ...
                doseSize(1), doseSize(2), doseSize(3));
            
            if maxDoseField == 0 || nonzeroDose == 0
                fprintf('     ERROR: Calculated dose is all zeros!\n');
                fieldDoses{beamIdx} = [];
                continue;
            end
            
            fprintf('     Dose calculated: Max = %.2f Gy, Non-zero voxels = %d\n', ...
                maxDoseField, nonzeroDose);
            
            % Store field dose (do this FIRST before any accumulation)
            fieldDoses{beamIdx} = struct();
            fieldDoses{beamIdx}.physicalDose = resultGUI.physicalDose;
            fieldDoses{beamIdx}.gantryAngle = stf(beamIdx).gantryAngle;
            fieldDoses{beamIdx}.couchAngle = stf(beamIdx).couchAngle;
            fieldDoses{beamIdx}.beamIdx = beamIdx;
            fieldDoses{beamIdx}.weights = w;
            fieldDoses{beamIdx}.maxDose = maxDoseField;
            
            fprintf('     Field dose stored successfully\n');
            
            % Initialize or accumulate total dose
            if isempty(totalDose)
                totalDose = zeros(doseSize);
                calculatedGridSize = doseSize;
                fprintf('    - Initialized totalDose: %d x %d x %d\n', ...
                    doseSize(1), doseSize(2), doseSize(3));
            end
            
            % Verify size compatibility before accumulation
            if isequal(doseSize, calculatedGridSize)
                try
                    totalDose = totalDose + resultGUI.physicalDose;
                    fprintf('     Added to totalDose (running max: %.2f Gy)\n', max(totalDose(:)));
                catch ME
                    fprintf('     WARNING: Could not add to totalDose: %s\n', ME.message);
                    fprintf('      Field dose is still saved individually\n');
                end
            else
                fprintf('     WARNING: Size mismatch with totalDose\n');
                fprintf('      Expected: %d x %d x %d\n', calculatedGridSize);
                fprintf('      Got: %d x %d x %d\n', doseSize);
                fprintf('      Field dose is still saved individually\n');
            end
            
            fprintf('\n');
        end
        
        % Final summary
        numSuccessful = sum(~cellfun(@isempty, fieldDoses));
        fprintf('  Summary: %d/%d fields calculated successfully\n', numSuccessful, length(stf));
        
        %% Step 6: Resample CT and field doses to RTDOSE grid
        fprintf('\n[6/7] Resampling CT and field doses to RTDOSE grid...\n');
        
        if ~isempty(referenceDose) && ~isempty(ctSpatial.ImagePositionPatient) && ~isempty(doseSpatial.ImagePositionPatient)
            
            fprintf('  Computing spatial transformation from CT to RTDOSE grid...\n');
            
            % --- Calculate coordinate systems ---
            % CT coordinate vectors (patient coordinates)
            ct_x = double(ctSpatial.ImagePositionPatient(1) + (0:ctSpatial.Columns-1) * ctSpatial.PixelSpacing(2));
            ct_y = double(ctSpatial.ImagePositionPatient(2) + (0:ctSpatial.Rows-1) * ctSpatial.PixelSpacing(1));
            ct_z = double(ctSpatial.SlicePositions);
            
            % RTDOSE coordinate vectors (patient coordinates)
            dose_x = double(doseSpatial.ImagePositionPatient(1) + (0:doseSpatial.Columns-1) * doseSpatial.PixelSpacing(2));
            dose_y = double(doseSpatial.ImagePositionPatient(2) + (0:doseSpatial.Rows-1) * doseSpatial.PixelSpacing(1));
            dose_z = double(doseSpatial.ImagePositionPatient(3) + doseSpatial.GridFrameOffsetVector);
            
            fprintf('    CT X range: [%.2f, %.2f] mm (%d points)\n', min(ct_x), max(ct_x), length(ct_x));
            fprintf('    CT Y range: [%.2f, %.2f] mm (%d points)\n', min(ct_y), max(ct_y), length(ct_y));
            fprintf('    CT Z range: [%.2f, %.2f] mm (%d points)\n', min(ct_z), max(ct_z), length(ct_z));
            fprintf('    Dose X range: [%.2f, %.2f] mm (%d points)\n', min(dose_x), max(dose_x), length(dose_x));
            fprintf('    Dose Y range: [%.2f, %.2f] mm (%d points)\n', min(dose_y), max(dose_y), length(dose_y));
            fprintf('    Dose Z range: [%.2f, %.2f] mm (%d points)\n', min(dose_z), max(dose_z), length(dose_z));
            
            % --- Resample CT to RTDOSE grid ---
            fprintf('\n  Resampling CT to RTDOSE grid...\n');
            
            % Get CT HU data
            ctCube = ct.cubeHU{1};
            fprintf('    Original CT size: %d x %d x %d\n', size(ctCube, 1), size(ctCube, 2), size(ctCube, 3));
            
            % Create meshgrid for CT coordinates
            [CT_Y, CT_X, CT_Z] = ndgrid(ct_y, ct_x, ct_z);
            CT_Y = double(CT_Y); 
            CT_X = double(CT_X); 
            CT_Z = double(CT_Z); 

            
            % Create query points at RTDOSE coordinates
            [DOSE_Y, DOSE_X, DOSE_Z] = ndgrid(dose_y, dose_x, dose_z);
            % Interpolate CT to RTDOSE grid
            try
                CT_X = double(CT_X); 
                
                ctResampled = interpn(CT_Y, CT_X, CT_Z, ctCube, ...
                                      DOSE_Y, DOSE_X, DOSE_Z, 'linear', -1000);
                fprintf('     CT resampled to RTDOSE grid: %d x %d x %d\n', ...
                    size(ctResampled, 1), size(ctResampled, 2), size(ctResampled, 3));
                fprintf('      CT HU range after resampling: [%.0f, %.0f]\n', ...
                    min(ctResampled(:)), max(ctResampled(:)));
            catch ME
                fprintf('     ERROR resampling CT: %s\n', ME.message);
                ctResampled = [];
            end
            
            % --- Resample field doses to RTDOSE grid ---
            fprintf('\n  Resampling field doses to RTDOSE grid...\n');
            
            % Field doses are on the CT grid, so use the same transformation
            fieldDosesResampled = cell(length(fieldDoses), 1);
            totalDoseResampled = zeros(length(dose_y), length(dose_x), length(dose_z));
            
            for beamIdx = 1:length(fieldDoses)
                if ~isempty(fieldDoses{beamIdx})
                    fprintf('    Resampling Field %d (Gantry: %.1f)...\n', ...
                        beamIdx, fieldDoses{beamIdx}.gantryAngle);
                    
                    fieldDose = fieldDoses{beamIdx}.physicalDose;
                    
                    % Verify field dose matches CT dimensions
                    if ~isequal(size(fieldDose), size(ctCube))
                        fprintf('       Field dose size (%d x %d x %d) differs from CT (%d x %d x %d)\n', ...
                            size(fieldDose, 1), size(fieldDose, 2), size(fieldDose, 3), ...
                            size(ctCube, 1), size(ctCube, 2), size(ctCube, 3));
                        fprintf('      Skipping this field\n');
                        fieldDosesResampled{beamIdx} = [];
                        continue;
                    end
                    
                    try
                        % Interpolate field dose to RTDOSE grid
                        fieldDoseResampled = interpn(CT_Y, CT_X, CT_Z, fieldDose, ...
                                                     DOSE_Y, DOSE_X, DOSE_Z, 'linear', 0);
                        
                        fprintf('       Resampled: %d x %d x %d, Max=%.4f Gy\n', ...
                            size(fieldDoseResampled, 1), size(fieldDoseResampled, 2), size(fieldDoseResampled, 3), ...
                            max(fieldDoseResampled(:)));
                        
                        % Store resampled field dose
                        fieldDosesResampled{beamIdx} = struct();
                        fieldDosesResampled{beamIdx}.physicalDose = fieldDoseResampled;
                        fieldDosesResampled{beamIdx}.gantryAngle = fieldDoses{beamIdx}.gantryAngle;
                        fieldDosesResampled{beamIdx}.couchAngle = fieldDoses{beamIdx}.couchAngle;
                        fieldDosesResampled{beamIdx}.beamIdx = fieldDoses{beamIdx}.beamIdx;
                        fieldDosesResampled{beamIdx}.weights = fieldDoses{beamIdx}.weights;
                        fieldDosesResampled{beamIdx}.maxDose = max(fieldDoseResampled(:));
                        fieldDosesResampled{beamIdx}.originalMaxDose = fieldDoses{beamIdx}.maxDose;
                        
                        % Accumulate total resampled dose
                        totalDoseResampled = totalDoseResampled + fieldDoseResampled;
                        
                    catch ME
                        fprintf('       ERROR resampling field: %s\n', ME.message);
                        fieldDosesResampled{beamIdx} = [];
                    end
                end
            end
            
            numResampledFields = sum(~cellfun(@isempty, fieldDosesResampled));
            fprintf('\n  Resampling complete: %d/%d fields resampled\n', numResampledFields, numSuccessful);
            fprintf('    Total resampled dose max: %.4f Gy\n', max(totalDoseResampled(:)));
            fprintf('    Reference dose max: %.4f Gy\n', max(referenceDose(:)));
            
            % --- Create resampled CT structure for kWave ---
            fprintf('\n  Creating resampled CT structure for kWave simulation...\n');
            
            ctResampled_struct = struct();
            ctResampled_struct.cubeHU = {ctResampled};
            ctResampled_struct.cubeDim = [size(ctResampled, 1), size(ctResampled, 2), size(ctResampled, 3)];
            ctResampled_struct.resolution.x = doseGrid.resolution(2);  % Column direction
            ctResampled_struct.resolution.y = doseGrid.resolution(1);  % Row direction
            ctResampled_struct.resolution.z = doseGrid.resolution(3);  % Slice direction
            ctResampled_struct.x = dose_x;
            ctResampled_struct.y = dose_y;
            ctResampled_struct.z = dose_z;
            ctResampled_struct.ImagePositionPatient = doseSpatial.ImagePositionPatient;
            ctResampled_struct.originalCTDim = ct.cubeDim;
            ctResampled_struct.originalCTResolution = [ct.resolution.x, ct.resolution.y, ct.resolution.z];
            
            fprintf('    Resampled CT structure created\n');
            fprintf('      Dimensions: %d x %d x %d\n', ctResampled_struct.cubeDim);
            fprintf('      Resolution: [%.2f, %.2f, %.2f] mm\n', ...
                ctResampled_struct.resolution.x, ctResampled_struct.resolution.y, ctResampled_struct.resolution.z);
            
        else
            fprintf('   Cannot resample - missing RTDOSE or spatial coordinates\n');
            fprintf('    Using original CT grid\n');
            ctResampled_struct = [];
            fieldDosesResampled = fieldDoses;
            totalDoseResampled = totalDose;
        end
        
        %% Step 7: Save results
        fprintf('\n[7/7] Saving results...\n');
        
        % Count successful calculations
        numSuccessful = sum(~cellfun(@isempty, fieldDoses));
        fprintf('  - Successfully calculated: %d/%d fields\n', numSuccessful, length(stf));
        
        if numSuccessful == 0
            fprintf('   ERROR: No fields were successfully calculated!\n');
            fprintf('  - Check MATRAD configuration and beam parameters\n');
            continue;
        end
        
        % Save original field doses (CT grid)
        save(fullfile(outputPath, 'fieldDoses_CTgrid.mat'), 'fieldDoses', 'stf', 'pln', 'ct', 'cst', 'totalDose');
        fprintf('  - Original field doses (CT grid) saved to: fieldDoses_CTgrid.mat\n');
        
        % Save resampled field doses (RTDOSE grid)
        if ~isempty(ctResampled_struct)
            save(fullfile(outputPath, 'fieldDoses.mat'), 'fieldDosesResampled', 'stf', 'pln', ...
                 'ctResampled_struct', 'cst', 'totalDoseResampled', 'referenceDose', 'doseGrid', ...
                 'ctSpatial', 'doseSpatial');
            fprintf('  - Resampled field doses (RTDOSE grid) saved to: fieldDoses.mat\n');
            
            % Save resampled CT separately for kWave
            save(fullfile(outputPath, 'ctResampled.mat'), 'ctResampled_struct', 'doseGrid', ...
                 'ctSpatial', 'doseSpatial');
            fprintf('  - Resampled CT saved to: ctResampled.mat\n');
        else
            % Fallback: save with original naming
            save(fullfile(outputPath, 'fieldDoses.mat'), 'fieldDoses', 'stf', 'pln', 'ct', 'cst');
            fprintf('  - Field doses saved to: fieldDoses.mat\n');
        end
        
        % Save reconstructed total dose if available
        if ~isempty(totalDoseResampled) && max(totalDoseResampled(:)) > 0
            calculatedGridSize = size(totalDoseResampled);
            save(fullfile(outputPath, 'reconstructedDose.mat'), 'totalDoseResampled', 'calculatedGridSize', ...
                 'referenceDose', 'doseGrid');
            fprintf('  - Reconstructed total dose saved\n');
            fprintf('    Total max dose: %.2f Gy\n', max(totalDoseResampled(:)));
        else
            fprintf('  - WARNING: Total dose is empty or zero, not saved\n');
            fprintf('  - Individual field doses are still available\n');
        end
        
        % Compare with reference if available
        if ~isempty(referenceDose) && ~isempty(totalDoseResampled)
            fprintf('\n  Comparing with reference RTDOSE...\n');
            
            % Check size compatibility
            if ~isequal(size(totalDoseResampled), size(referenceDose))
                fprintf('    Dose grid size mismatch:\n');
                fprintf('      Calculated: %d x %d x %d\n', size(totalDoseResampled));
                fprintf('      Reference:  %d x %d x %d\n', size(referenceDose));
                
                % Save without direct comparison
                comparison.calculated = totalDoseResampled;
                comparison.reference = referenceDose;
                comparison.note = 'Grid size mismatch - direct comparison not possible';
                comparison.calculatedGrid = size(totalDoseResampled);
                comparison.referenceGrid = size(referenceDose);
                save(fullfile(outputPath, 'doseComparison.mat'), 'comparison');
            else
                % Sizes match - can compare directly
                doseDiff = totalDoseResampled - referenceDose;
                
                fprintf('     Grids match! Direct comparison possible.\n');
                fprintf('    Comparison statistics:\n');
                fprintf('      Calculated max dose: %.2f Gy\n', max(totalDoseResampled(:)));
                fprintf('      Reference max dose:  %.2f Gy\n', max(referenceDose(:)));
                fprintf('      Mean absolute difference: %.2f Gy\n', mean(abs(doseDiff(:))));
                fprintf('      Max difference: %.2f Gy\n', max(abs(doseDiff(:))));
                fprintf('      RMS difference: %.2f Gy\n', sqrt(mean(doseDiff(:).^2)));
                
                % Calculate relative differences in high dose region
                highDoseThreshold = 0.5 * max(referenceDose(:));
                highDoseMask = referenceDose > highDoseThreshold;
                if any(highDoseMask(:))
                    relativeDiff = abs(doseDiff(highDoseMask)) ./ referenceDose(highDoseMask) * 100;
                    fprintf('      Mean relative diff (>50%% max): %.2f%%\n', mean(relativeDiff));
                end
                
                % Save comparison
                comparison.calculated = totalDoseResampled;
                comparison.reference = referenceDose;
                comparison.difference = doseDiff;
                comparison.gridResolution = doseGrid.resolution;
                comparison.gridDimensions = doseGrid.dimensions;
                comparison.note = 'Field doses and CT resampled to RTDOSE grid';
                comparison.metrics.meanAbsDiff = mean(abs(doseDiff(:)));
                comparison.metrics.maxDiff = max(abs(doseDiff(:)));
                comparison.metrics.rmsDiff = sqrt(mean(doseDiff(:).^2));
                if any(highDoseMask(:))
                    comparison.metrics.meanRelativeDiff = mean(relativeDiff);
                end
                save(fullfile(outputPath, 'doseComparison.mat'), 'comparison');
                
                fprintf('     Comparison saved to doseComparison.mat\n');
            end
        elseif ~isempty(referenceDose) && isempty(totalDoseResampled)
            fprintf('  - Cannot compare: totalDoseResampled was not calculated\n');
        end
        
        % Export individual field doses to DICOM
        fprintf('\n  Exporting field doses to .mat files...\n');
        for beamIdx = 1:length(fieldDosesResampled)
            if ~isempty(fieldDosesResampled{beamIdx})
                try
                    fieldFilename = sprintf('Field_%02d.mat', beamIdx);
                    fieldData = fieldDosesResampled{beamIdx};
                    save(fullfile(outputPath, fieldFilename), 'fieldData');
                catch
                    fprintf('    Warning: Could not export field %d\n', beamIdx);
                end
            end
        end
        
        fprintf('\n========================================\n');
        fprintf('Processing complete for %s - %s\n', currentID, currentSession);
        fprintf('Results saved to: %s\n', outputPath);
        fprintf('========================================\n');
        
        fprintf('\n** IMPORTANT NOTES **\n');
        fprintf('1. Grid Resampling:\n');
        if ~isempty(ctResampled_struct)
            fprintf('    CT and field doses resampled to RTDOSE grid\n');
            fprintf('     Original CT: %d x %d x %d at [%.2f, %.2f, %.2f] mm\n', ...
                ct.cubeDim(1), ct.cubeDim(2), ct.cubeDim(3), ...
                ct.resolution.x, ct.resolution.y, ct.resolution.z);
            fprintf('     Resampled:   %d x %d x %d at [%.2f, %.2f, %.2f] mm\n', ...
                ctResampled_struct.cubeDim(1), ctResampled_struct.cubeDim(2), ctResampled_struct.cubeDim(3), ...
                ctResampled_struct.resolution.x, ctResampled_struct.resolution.y, ctResampled_struct.resolution.z);
        else
            fprintf('    Resampling not performed - using original CT grid\n');
        end
        fprintf('\n');
        
        fprintf('2. MLC Aperture Status:\n');
        if isfield(pln, 'propStf') && isfield(pln.propStf, 'beam') && ...
           length(pln.propStf.beam) > 0 && isfield(pln.propStf.beam(1), 'shape')
            fprintf('    MLC data imported by MATRAD\n');
            if exist('reduce_collimator', 'file')
                fprintf('    Dual-layer MLC reduced to single-layer\n');
            end
            % Check if it made it to stf
            if (isfield(stf, 'shape') && isfield(stf(1), 'shape')) || ...
               (isfield(stf(1), 'ray') && isfield(stf(1).ray(1), 'shape'))
                fprintf('    MLC shapes present in steering file\n');
                fprintf('    Dose calculations should include MLC shaping\n');
            else
                fprintf('    MLC shapes not detected in steering file\n');
                fprintf('   - Fields may be calculated as open fields\n');
            end
        else
            fprintf('    No MLC data imported from RTPLAN\n');
            fprintf('   - MATRAD calculated dose for open fields\n');
            fprintf('   - Calculated fields will be larger than clinical fields\n');
        end
        fprintf('\n');
        
        fprintf('3. Weight Extraction:\n');
        if isfield(pln, 'w') && ~isempty(pln.w)
            fprintf('    Weights successfully extracted from RTPLAN\n');
            fprintf('   - Using beam metersets: total = %.2f\n', sum(pln.w));
        else
            fprintf('    Weights could not be extracted\n');
            fprintf('   - Uniform weights used for all bixels\n');
            fprintf('   - Relative field contributions may not match clinical plan\n');
        end
        fprintf('\n');
        
        fprintf('4. Machine Commissioning:\n');
        fprintf('   - Using generic photon machine data (not Halcyon-specific)\n');
        fprintf('   - Absolute dose values will differ from clinical plan\n');
        fprintf('   - Dose distributions and relative contributions are still valid for QA\n\n');
        
        fprintf('5. Output Files:\n');
        fprintf('   - fieldDoses.mat: Resampled field doses (RTDOSE grid) for kWave\n');
        fprintf('   - fieldDoses_CTgrid.mat: Original field doses (CT grid)\n');
        fprintf('   - ctResampled.mat: CT resampled to RTDOSE grid for kWave\n');
        fprintf('   - reconstructedDose.mat: Total accumulated dose\n');
        fprintf('   - doseComparison.mat: Comparison with reference RTDOSE\n\n');
        
    end
end

fprintf('\n\nAll processing complete!\n');
